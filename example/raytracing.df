// 画布
var nx,ny =512,512
var buffer=(float,float,float)[nx,ny]
// 相机参数
var lookfrom = (float,float,float)
var lookat = (float,float,float)
var up = (float,float,float)

var fov = 60				// 视角
var aspect = ny / nx		// 长宽比

cam_lower_left_corner = (float,float,float)
cam_horizontal = (float,float,float)
cam_vertical = (float,float,float)
cam_origin = (float,float,float)

// 球体列表

// 归一化
def normalization(v)=> (1 / v.norm()) * v
def generate_cam_parameter(){
    lookat = (0.0, 1.0, -1.0)
    up = (0.0, 1.0, 0.0)
    theta = fov * (math.pi / 180.0)
    var half_height = math.tan(theta / 2.0)
    var half_width = aspect * half_height
    cam_origin = lookfrom
    var w = normalization(lookfrom - lookat)
    var u = normalization(up.cross(w))
    var v = w.cross(u)
    cam_lower_left_corner = (-half_width, -half_height, -1.0)
    cam_lower_left_corner = cam_origin - half_width * u - half_height * v - w
    cam_horizontal = 2 * half_width * u
    cam_vertical = 2 * half_height * v
}

def random_in_unit_sphere(){
    p = 2.0 * (ti.random(), ti.random(),ti.random()) - (1, 1, 1)
    while (p[0] * p[0] + p[1] * p[1] + p[2] * p[2] >= 1.0)
        p = 2.0 * (ti.random(), ti.random(), ti.random()) - (1, 1, 1)
    return p
}

def cam_get_ray(u, v){
    return  cam_origin, cam_lower_left_corner + u * cam_horizontal + v * cam_vertical - cam_origin
}

def reflect(v, n)=> v - 2 * v.dot(n) * n


def scatter(ray_origin, ray_direction, hit_p, hit_normal, hit_material,hit_fuzz){
    var scattered_ray_origin = hit_p
    var scattered_ray_direction = (0.0,0.0,0.0)
    var flag = False
    if (hit_material == 1){
        var target = hit_p + hit_normal + random_in_unit_sphere()
        scattered_ray_direction = target - hit_p
        flag = True
		}
    else if(hit_material == 2){  # 金属
        var reflected = reflect(normalization(ray_direction), hit_normal)
        scattered_ray_direction = reflected + hit_fuzz * random_in_unit_sphere()  # 后一项为光泽度
        flag = scattered_ray_direction.dot(hit_normal) > 0
		}
    return flag, scattered_ray_origin, scattered_ray_direction
	}












	@ti.func
def hit_sphere(sphere_center, sphere_radius, ray_origin, ray_direction, t_min, t_max):
    var oc = ray_origin - sphere_center
    var a = ray_direction.dot(ray_direction)
    var b = oc.dot(ray_direction)
    var c = oc.dot(oc) - sphere_radius * sphere_radius
    var discriminant = b * b - a * c

    hit_flag = False
    hit_t = 0.0
    hit_p = ti.Vector([0.0, 0.0, 0.0])
    hit_normal = ti.Vector([0.0, 0.0, 0.0])
    if discriminant > 0.0:
        temp = (-b - ti.sqrt(b * b - a * c)) / a
        if temp < t_max and temp > t_min:
            hit_t = temp
            hit_p = ray_origin + hit_t * ray_direction
            hit_normal = (hit_p - sphere_center) / sphere_radius
            hit_flag = True
        if hit_flag == False:
            temp = (-b + ti.sqrt(b * b - a * c)) / a
            if temp < t_max and temp > t_min:
                hit_t = temp
                hit_p = ray_origin + hit_t * ray_direction
                hit_normal = (hit_p - sphere_center) / sphere_radius
                hit_flag = True
    return hit_flag, hit_t, hit_p, hit_normal



def hit_all_spheres(ray_origin, ray_direction, t_min, t_max):
    hit_anything = False
    hit_t = 0.0
    hit_p = ti.Vector([0.0, 0.0, 0.0])
    hit_normal = ti.Vector([0.0, 0.0, 0.0])
    hit_material = 1
    hit_material_color = ti.Vector([0.0, 0.0, 0.0])
    hit_fuzz = 0.0
    closest_so_far = t_max
    for i in range(sphere_num):
        hit_flag, temp_hit_t, temp_hit_p, temp_hit_normal = \
            hit_sphere(sphere_origin_list[i], sphere_radius_list[i], ray_origin, ray_direction, t_min, closest_so_far)
        if hit_flag:
            hit_anything = True
            closest_so_far = temp_hit_t
            hit_t = temp_hit_t
            hit_p = temp_hit_p
            hit_normal = temp_hit_normal
            hit_material = sphere_material_list[i]
            hit_material_color = sphere_material_color_list[i]
            hit_fuzz = sphere_metal_fuzz_list[i]
    return hit_anything, hit_t, hit_p, hit_normal, hit_material, hit_material_color, hit_fuzz


@ti.func
def color(ray_origin, ray_direction):
    col = ti.Vector([0.0, 0.0, 0.0])
    coefficient = ti.Vector([1.0, 1.0, 1.0])
    for i in range(10):
        hit_flag, hit_t, hit_p, hit_normal, hit_material, hit_material_color, hit_fuzz = \
            hit_all_spheres(ray_origin, ray_direction, 0.001, 10e9)
        if hit_flag:
            if hit_material == 3:  # 光源
                col = coefficient * hit_material_color
                break

            flag, ray_origin, ray_direction = \
                scatter(ray_origin, ray_direction, hit_p, hit_normal, hit_material, hit_fuzz)
            if flag:
                coefficient *= hit_material_color  # 衰减
            else:
                break
        else:
            unit_direction = normalization(ray_direction)
            t = 0.5 * (unit_direction.y + 1.0)
            col = (1.0 - t) * ti.Vector([1.0, 1.0, 1.0]) + t * ti.Vector(
                [0.5, 0.7, 1.0])
            col *= coefficient
            break
    return col


@ti.kernel
def draw():
    if lookfrom[None][0] < 1.0:
        lookfrom[None][0] += 0.1
    else:
        lookfrom[None][0] = -1.0
    generate_cam_parameter()
    for i, j in screen:
        col = ti.Vector([0.0, 0.0, 0.0])
        for s in range(100):
            u = float(i + ti.random()) / float(nx)  # random是为抗锯齿
            v = float(j + ti.random()) / float(ny)
            ray_origin, ray_direction = cam_get_ray(u, v)
            col += color(ray_origin, ray_direction)
        col /= float(100)
        col = ti.sqrt(col)
        screen[i, j] = col
# video_manger = ti.VideoManager(output_dir='./results', framerate=24, automatic_build=False)
gui = ti.GUI("screen", (nx, ny))

for i in range(40):
    draw()
    gui.set_image(screen.to_numpy())
    gui.show()
    # video_manger.write_frame(screen.to_numpy())

# video_manger.make_video(gif=True, mp4=True)
